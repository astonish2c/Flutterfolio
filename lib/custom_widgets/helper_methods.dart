import 'package:decimal/decimal.dart';
import 'package:intl/intl.dart';

import '../models/coin_model.dart';

///Converts crypto prices from double to currency.
String currencyConverter(double num, {bool isCurrency = true}) {
  if (num == 0) return '\$$num';

  double localNum = num;

  //No need of conversion if less than 1000 and is not money related
  if (localNum < 1000 && !isCurrency) {
    return localNum.toString();
  }

  //if num is negative, we remove negative sign off of it
  if (localNum.toString().contains('-')) {
    final List<String> digits = localNum.toString().split('');
    digits.removeAt(0);
    localNum = double.parse(digits.join());
  }

  late int allowedDecimals;

  final String decimals = (Decimal.parse(localNum.toString())).toString().split('.').last;

  //checking each digit after decimal point
  for (int i = 0; i < decimals.length; i++) {
    final int digit = int.parse(decimals[i]);

    //if digit > zero at first index after decimal point. (0.1)
    if (i == 0 && digit > 0) {
      if (localNum >= 1) {
        allowedDecimals = 2;
      } else if (localNum >= 0.1) {
        allowedDecimals = 3;
      }
      break;
      //if digit > zero at other index other than zero. (0.001 || 0.00001)
    } else if (digit > 0) {
      if (localNum <= 0.1) {
        allowedDecimals = i + 3;
      } else {
        allowedDecimals = i + 1;
      }
      break;
    }
  }
  //converted to currency || or just added comma, if(!currency)
  String currency = NumberFormat.currency(
    symbol: isCurrency ? '\$' : '',
    decimalDigits: allowedDecimals,
    locale: 'en_US',
  ).format(localNum);

  //removing trailing zeros generated by use of NumberFormat()
  String currencyDecimals = currency.split('.').last;
  if (int.parse(currencyDecimals) == 0) {
    return currency.split('.').first;
  } else {
    return currency;
  }
}

double calTotalCost(CoinModel coin) {
  double totalCost = 0;

  for (Transaction transaction in coin.transactions!) {
    final double singleTransactionCost = transaction.buyPrice * transaction.amount;

    totalCost += singleTransactionCost;
  }

  return totalCost;
}

extension StringCasingExtension on String {
  String toCapitalized() => length > 0 ? '${this[0].toUpperCase()}${substring(1).toLowerCase()}' : '';
}

extension DoubleCasingExtension on String {
  String removeTrailingZerosAndNumberfy() {
    return replaceAll(RegExp(r"([.]*0+)(?!.*\d)"), "");
  }
}

String convertPerToNum(String percentage) {
  final doubleStr = double.parse(percentage).toStringAsFixed(2);
  return doubleStr;
}
